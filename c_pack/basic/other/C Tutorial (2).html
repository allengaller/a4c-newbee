
<!-- saved from url=(0092)http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#io -->
<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=GBK">
<TITLE>C Tutorial</TITLE>
</HEAD><BODY bgcolor="#ffffee">

<CENTER><H2> C Language Tutorial </H2></CENTER>

<P>
<B>Table of Contents:</B>
</P><UL>
<LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#first">1. A First Program</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#compute">2. Let's Compute</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#loops">3. Loops</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#symbolic">4. Symbolic Constants</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#conditionals">5. Conditionals</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#pointers">6. Pointers</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#arrays">7. Arrays</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#character">8. Character Arrays</A>
</LI><LI> <A href="./C Tutorial_files/C Tutorial.html">9. I/O Capabilities</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#functions">10. Functions</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#command-line">11. Command-line Arguments</A>
</LI><LI> <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/c_tutorial.html#dialog-box">12. Graphical Interfaces: Dialog Boxes</A>
</LI></UL>
<HR>

<P> This section contains a brief introduction to the C language.  It
is intended as a tutorial on the language, and aims at getting a
reader new to C started as quickly as possible.  It is certainly
<EM>not</EM> intended as a substitute for any of the numerous
textbooks on C.</P><P>

The best way to learn a new ``human'' language is to speak it right
from the outset, listening and repeating, leaving the intricacies of
the grammar for later.  The same applies to computer languages--to
learn C, we must start writing C programs as quickly as possible.

</P><P>
An excellent textbook on C by two well-known and widely respected
authors is:
</P><PRE><B> The C Programming Language -- ANSI C </B>
<I> Brian W. C. Kernighan &amp; Dennis M. Ritchie </I>
<I> Prentice Hall, 1988 </I>
</PRE>

Dennis Ritchie designed and implemented the first C compiler on a
PDP-11 (a prehistoric machine by today's standards, yet one which had
enormous influence on modern scientific computation). The C language
was based on two (now defunct) languages: BCPL, written by Martin
Richards, and B, written by Ken Thompson in 1970 for the first UNIX
system on a PDP-7.  The original ``official'' C language was the ``K
&amp; R'' C, the nickname coming from the names of the two authors of
the original ``The C Programming Language''.  In 1988, the American
National Standards Institute (ANSI) adopted a ``new and improved''
version of C, known today as ``ANSI C''. This is the version described
in the current edition of ``The C Programming Language -- ANSI
C''. The ANSI version contains many revisions to the syntax and the
internal workings of the language, the major ones being improved
calling syntax for procedures and standarization of most (but,
unfortunately, not quite all!) system libraries.

<P><BR>

</P><H2>  <A name="first">1. A First Program </A> </H2>

Let's be polite and start by saluting the world!  Type the following
program into your favorite <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/UNIX/editors.html">editor</A>:

<PRE><HR>
#include &lt; stdio.h&gt;

void main()
{
    printf("\nHello World\n");
}
<HR>
</PRE>

Save the code in the file <KBD>hello.c</KBD>, then <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/compile.html">compile</A> it by typing:

<PRE>	gcc hello.c
</PRE>

<P> This creates an <I>executable</I> file <KBD>a.out</KBD>, which is
then executed simply by typing its name. The result is that the
characters `` <KBD>Hello World</KBD>'' are printed out, preceded by
an empty line.

</P><P> A C program contains <I>functions</I> and <I>variables</I>.  The
functions specify the tasks to be performed by the program. The
``main'' function establishes the overall logic of the code. It is
normally kept short and calls different functions to perform the
necessary sub-tasks.  All C codes must have a ``main'' function.

</P><P> Our <KBD>hello.c</KBD> code calls <KBD>printf</KBD>, an output
function from the I/O (input/output) library (defined in the file
<KBD>stdio.h</KBD>). The original C language did not have any built-in
I/O statements whatsoever.  Nor did it have much arithmetic
functionality.  The original language was really not intended for
''scientific'' or ''technical'' computation..  These functions are now
performed by standard libraries, which are now part of ANSI C. The K
&amp; R textbook lists the content of these and other standard
libraries in an appendix.

</P><P> The <KBD>printf</KBD> line prints the message ``<KBD>Hello
World</KBD>'' on ``<KBD>stdout</KBD>'' (the output stream
corresponding to the X-terminal window in which you run the code);
``<KBD>\n</KBD>'' prints a ``new line'' character, which brings the
cursor onto the next line.  By construction, <KBD>printf</KBD> never
inserts this character on its own: the following program would produce
the same result:

</P><PRE><HR>
#include &lt; stdio.h&gt;

void main()
{
    printf("\n");
    printf("Hello World");
    printf("\n");
}
<HR>
</PRE>

Try leaving out the ``<KBD>\n</KBD>'' lines and see what happens.

<P> The first statement ``<KBD>#include &lt; stdio.h&gt;</KBD>'' includes
a specification of the C I/O library.  All variables in C must be
explicitly defined before use: the ``<KBD>.h</KBD>'' files are by
convention ``header files'' which contain definitions of variables and
functions necessary for the functioning of a program, whether it be in
a user-written section of code, or as part of the standard C libaries.
The directive ``<KBD>#include</KBD>'' tells the C compiler to insert
the contents of the specified file at that point in the code. The
``<KBD>&lt; ...&gt;</KBD>'' notation instructs the compiler to look for
the file in certain ``standard'' system directories.

</P><P> The <KBD>void</KBD> preceeding ``<KBD>main</KBD>'' indicates that
main is of ``void'' type--that is, it has <EM>no</EM> type associated
with it, meaning that it cannot return a result on execution.

</P><P> The ``;'' denotes the end of a statement. Blocks of statements are
put in braces {...}, as in the definition of functions.  All C
statements are defined in free format, i.e., with no specified layout
or column assignment. Whitespace (tabs or spaces) is never
significant, except inside quotes as part of a character string. The
following program would produce exactly the same result as our earlier
example:

</P><PRE>#include &lt; stdio.h&gt;
void main(){printf("\nHello World\n");}
</PRE>

<P> The reasons for arranging your programs in lines and indenting to
show structure should be obvious!

</P><P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="compute">2. Let's Compute </A> </H2>

The following program, <KBD>sine.c</KBD>, computes a table of the sine
function for angles between 0 and 360 degrees.


<PRE><HR>
				/************************/
				/*   Table of 		*/	
				/*   Sine Function	*/
				/************************/
				
				/* Michel Vallieres 	*/
				/* Written: Winter 1995	*/
#include &lt; stdio.h&gt;
#include &lt; math.h&gt;

void main()
{
    int    angle_degree;
    double angle_radian, pi, value;

					/* Print a header */
    printf ("\nCompute a table of the sine function\n\n");

					/* obtain pi once for all */
					/* or just use pi = M_PI, where
					   M_PI is defined in math.h 	*/
    pi = 4.0*atan(1.0);
    printf ( " Value of PI = %f \n\n", pi );

    printf ( " angle     Sine \n" );

    angle_degree=0;			/* initial angle value 		 */
					/* scan over angle 		 */

    while (  angle_degree &lt;= 360 )	/* loop until angle_degree &gt; 360 */
    {
       angle_radian = pi * angle_degree/180.0 ;
       value = sin(angle_radian);
       printf ( " %3d      %f \n ", angle_degree, value );

       angle_degree = angle_degree + 10; /* increment the loop index	 */
    }
}
<HR>
</PRE>

The code starts with a series of comments indicating its the purpose,
as well as its author. It is considered good programming style to
identify and document your work (although, sadly, most people only do
this as an afterthought).  Comments can be written anywhere in the
code: any characters between /* and */ are ignored by the compiler and
can be used to make the code easier to understand.  The use of
variable names that are meaningful within the context of the problem
is also a good idea.

<P> The <KBD>#include</KBD> statements now also include the header
file for the standard mathematics library <KBD>math.h</KBD>. This
statement is needed to define the calls to the trigonometric functions
<KBD>atan</KBD> and <KBD>sin</KBD>.  Note also that the <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/compile.html">compilation</A> must include the mathematics
library explicitly by typing

</P><P>
</P><PRE>	gcc sine.c -lm
</PRE>

<P> Variable names are arbitrary (with some compiler-defined maximum
length, typically 32 characters). C uses the following standard
variable types:

</P><PRE>int    -&gt; integer variable
short  -&gt; short integer
long   -&gt; long integer
float  -&gt; single precision real (floating point) variable
double -&gt; double precision real (floating point) variable
char   -&gt; character variable (single byte)
</PRE>

The compilers checks for consistency in the types of all variables
used in any code.  This feature is intended to prevent mistakes, in
particular in mistyping variable names.  Calculations done in the math
library routines are usually done in double precision arithmetic (64
bits on most workstations).  The actual number of bytes used in the
internal storage of these data types depends on the machine being
used.

<P> The <KBD>printf</KBD> function can be instructed to print integers,
floats and strings properly. The general syntax is

</P><PRE>	printf( "format", variables );
</PRE>

where <KBD>"format"</KBD> specifies the converstion specification and
<KBD>variables</KBD> is a list of quantities to print.  Some useful
formats are

<PRE>%.nd	integer (optional n = number of columns; if 0, pad with zeroes)
%m.nf	float or double (optional m = number of columns,
			 	  n = number of decimal places)
%ns	string (optional n = number of columns)
%c    	character
\n \t 	to introduce new line or tab
\g	ring the bell (``beep'') on the terminal
</PRE>

<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="loops">3. Loops </A></H2>

Most real programs contain some construct that loops within the
program, performing repetitive actions on a stream of data or a region
of memory.  There are several ways to loop in C. Two of the most
common are the <KBD>while</KBD> loop:

<PRE>    while (expression)
    {
	...block of statements to execute...
    }
</PRE>

and the <KBD>for</KBD> loop:

<PRE>    for (expression_1; expression_2; expression_3)
    {
	...block of statements to execute...
    }
</PRE>


The <KBD>while</KBD> loop continues to loop until the conditional
<KBD>expression</KBD> becomes false. The condition is tested upon
entering the loop. Any logical construction (see below for a list) can
be used in this context.

<P> The <KBD>for</KBD> loop is a special case, and is equivalent to
the following while loop:

</P><PRE>    expression_1;

    while (expression_2)
    {
	...block of statements...

	expression_3;
    }
</PRE>

For instance, the following structure is often encountered:

<PRE>    i = initial_i;

    while (i &lt;= i_max)
    {
     	...block of statements...

	i = i + i_increment;
    }
</PRE>

This structure may be rewritten in the easier syntax of the
<KBD>for</KBD> loop as:

<PRE>    for (i = initial_i; i &lt;= i_max; i = i + i_increment)
    {
	...block of statements...
    }
</PRE>

Infinite loops are possible (e.g. <KBD>for(;;)</KBD>), but not too
good for your computer budget!  C permits you to write an infinite
loop, and provides the <KBD>break</KBD> statement to ``breakout '' of
the loop.  For example, consider the following (admittedly
not-so-clean) re-write of the previous loop:

<PRE>    angle_degree = 0;

    for ( ; ; )
    {
	...block of statements...

	angle_degree = angle_degree + 10;
	if (angle_degree == 360) break;
    }
</PRE>

The conditional <KBD>if</KBD> simply asks whether
<KBD>angle_degree</KBD> is equal to 360 or not; if yes, the loop is
stopped.


<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="symbolic">4. Symbolic Constants </A></H2>

You can define constants of any type by using the <KBD>#define</KBD>
compiler directive. Its syntax is simple--for instance

<PRE>#define ANGLE_MIN 0
#define ANGLE_MAX 360
</PRE>

would define <KBD>ANGLE_MIN</KBD> and <KBD>ANGLE_MAX</KBD> to the
values 0 and 360, respectively. C distinguishes between lowercase and
uppercase letters in variable names. It is customary to use capital
letters in defining global constants.


<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="conditionals">5. Conditionals </A></H2>

Conditionals are used within the <KBD>if</KBD> and <KBD>while</KBD>
constructs:

<PRE>    if (conditional_1) 
    {
	...block of statements executed if conditional_1 is true...
    }
    else if (conditional_2)
    {
	...block of statements executed if conditional_2 is true...
    }
    else
    {
	...block of statements executed otherwise...
    }
</PRE>

and any variant that derives from it, either by omitting branches or
by including nested conditionals.

<P> Conditionals are logical operations involving comparison of
quantities (of the same type) using the conditional operators:

</P><PRE>	&lt;		smaller than
 	&lt;=		smaller than or equal to
	==		equal to
	!=		not equal to
	&gt;=		greater than or equal to
	&gt;		greater than
</PRE>

and the boolean operators

<PRE>	&amp;&amp; 		and
	||		or
	!		not
</PRE>

<P>
Another conditional use is in the <KBD>switch</KBD> construct:

</P><PRE>    switch (expression)
    {
	case const_expression_1:
	{
	    ...block of statements...
            break;
	}
	case const_expression_2:
	{
	    ...block of statements...
            break;
	}
	default:
	{
	    ...block of statements..
	}
    }
</PRE>

The appropriate block of statements is executed according to the value
of the expression, compared with the constant expressions in the case
statement. The <KBD>break</KBD> statements insure that 
the statements in the cases following the chosen one
will not be executed. If you would want to execute these
statements, then you would leave out the <KBD> break </KBD>
statements.
This construct is particularly useful in handling input
variables.


<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="pointers">6. Pointers </A></H2>

The C language allows the programmer to ``peek and poke'' directly
into memory locations.  This gives great flexibility and power to the
language, but it also one of the great hurdles that the beginner must
overcome in using the language.

<P>
All variables in a program reside in memory; the statements

</P><PRE>    float x;
    x = 6.5;
</PRE>

request that the compiler reserve 4 bytes of memory (on a 32-bit
computer) for the floating-point variable <KBD>x</KBD>, then put the
``value'' 6.5 in it.

<P> Sometimes we want to know where a variable resides in memory. The
address (location in memory) of any variable is obtained by placing
the operator ``<KBD>&amp;</KBD>'' before its name. Therefore
<KBD>&amp;ampx</KBD> is the address of <KBD>x</KBD>.  C allows us to go
one stage further and define a variable, called a <EM>pointer</EM>,
that contains the address of (i.e. ``points to'') other variables.
For example:

</P><PRE>    float x;
    float* px;

    x = 6.5;
    px = &amp;x;
</PRE>

defines <KBD>px</KBD> to be a pointer to objects of type float, and
sets it equal to the address of <KBD>x</KBD>:

<P> 
</P><CENTER>
<IMG src="./C Tutorial_files/pointer-1.gif"> <BR>
Pointer use for a variable 
</CENTER>
 
<P>The content of the memory location referenced by a pointer is
obtained using the ``<KBD>*</KBD>'' operator (this is called
<EM>dereferencing</EM> the pointer).  Thus, <KBD>*px</KBD> refers to
the value of <KBD>x</KBD>.

</P><P>C allows us to perform arithmetic operations using pointers, but
beware that the ``unit'' in pointer arithmetic is the size (in bytes)
of the object to which the pointer points.  For example, if
<KBD>px</KBD> is a pointer to a variable <KBD>x</KBD> of type
<KBD>float</KBD>, then the expression <KBD>px + 1</KBD> refers not to
the next bit or byte in memory but to the location of the next
<KBD>float</KBD> after <KBD>x</KBD> (4 bytes away on most
workstations); if <KBD>x</KBD> were of type <KBD>double</KBD>, then
<KBD>px + 1</KBD> would refer to a location 8 bytes (the size of a
<KBD>double</KBD>)away, and so on.  Only if <KBD>x</KBD> is of type
<KBD>char</KBD> will <KBD>px + 1</KBD> actually refer to the next byte
in memory.

</P><P>Thus, in

</P><PRE>    char* pc;
    float* px;
    float x;

    x = 6.5;
    px = &amp;x;
    pc = (char*) px;
</PRE>

(the <KBD>(char*)</KBD> in the last line is a ``cast'', which converts
one data type to another), <KBD>px</KBD> and <KBD>pc</KBD> both point
to the same location in memory--the address of <KBD>x</KBD>--but
<KBD>px + 1</KBD> and <KBD>pc + 1</KBD> point to <EM>different</EM>
memory locations.

<P>Consider the following simple code.

</P><PRE><HR>
void main()
{
    float x, y;				/* x and y are of float type	     */
    float *fp, *fp2;			/* fp and fp2 are pointers to float  */

    x = 6.5;				/* x now contains the value 6.5	     */

					/* print contents and address of x   */
    printf("Value of x is %f, address of x %ld\n", x, &amp;x);
	
    fp = &amp;x;				/* fp now points to location of x    */
		
					/* print the contents of fp	     */
    printf("Value in memory location fp is %f\n", *fp);

					/* change content of memory location */
    *fp = 9.2;
    printf("New value of x is %f = %f \n", *fp, x);

					/* perform arithmetic 	             */
    *fp = *fp + 1.5;
    printf("Final value of x is %f = %f \n", *fp, x);

					/* transfer values                   */
    y = *fp;
    fp2 = fp;
    printf("Transfered value into y = %f and fp2 = %f \n", y, *fp2);
}
<HR>
</PRE>

Run this code to see the results of these different operations.  Note
that, while the value of a pointer (if you print it out with
<KBD>printf</KBD>) is typically a large integer, denoting some
particular memory location in the computer, pointers are <EM>not</EM>
integers--they are a completely different data type.


<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="arrays">7. Arrays </A></H2>

Arrays of any type can be formed in C. The syntax is simple:

<PRE>	type name[dim];
</PRE>

In C, arrays starts at position 0. The elements of the array occupy
adjacent locations in memory.  C treats the name of the array as if it
were a pointer to the first element--this is important in
understanding how to do arithmetic with arrays.  Thus, if <KBD>v</KBD>
is an array, <KBD>*v</KBD> is the same thing as <KBD>v[0]</KBD>,
<KBD>*(v+1)</KBD> is the same thing as <KBD>v[1]</KBD>, and so on:

<P>
</P><CENTER>
<IMG src="./C Tutorial_files/pointer-2.gif"> <BR>
Pointer use for an array
</CENTER>

<P> Consider the following code, which illustrates the use of
pointers:

</P><PRE><HR>
#define SIZE 3

void main()
{
    float x[SIZE];
    float *fp;
    int   i;
					/* initialize the array x         */
					/* use a "cast" to force i        */
					/* into the equivalent float      */
    for (i = 0; i &lt; SIZE; i++)
	x[i] = 0.5*(float)i;
					/* print x                        */
    for (i = 0; i &lt; SIZE; i++)
	printf("  %d  %f \n", i, x[i]);
					/* make fp point to array x       */
    fp = x;
					/* print via pointer arithmetic   */
					/* members of x are adjacent to   */
					/* each other in memory	          */
					/* *(fp+i) refers to content of	  */
					/* memory location (fp+i) or x[i] */
    for (i = 0; i &lt; SIZE; i++)
	printf("  %d  %f \n", i, *(fp+i));
}
<HR>
</PRE>

(The expression ``<KBD>i++</KBD>'' is C shorthand for ``<KBD>i = i +
1</KBD>''.)  Since <KBD>x[i]</KBD> means the <KBD>i</KBD>-th element
of the array <KBD>x</KBD>, and <KBD>fp = x</KBD> points to the start
of the <KBD>x</KBD> array, then <KBD>*(fp+i)</KBD> is the content of
the memory address <KBD>i</KBD> locations beyond <KBD>fp</KBD>, that
is, <KBD>x[i]</KBD>.

 
<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="character">8. Character Arrays </A></H2>
 
A <I> string constant </I>, such as 

<PRE>	"I am a string"
</PRE>

is an array of characters. It is represented internally in C by the
ASCII characters in the string, i.e., ``<KBD>I</KBD>'', blank,
``<KBD>a</KBD>'', ``<KBD>m</KBD>'',... for the above string, and
terminated by the special null character ``<KBD>\0</KBD>'' so programs
can find the end of the string.
 
<P>
String constants are often used in making the output
of code intelligible using <KBD> printf </KBD>;
</P><PRE>	printf("Hello, world\n");
	printf("The value of a is: %f\n", a);
</PRE>
 
<P> String constants can be associated with variables. C provides the
<KBD>char</KBD> type variable, which can contain one character--1
byte--at a time. A character string is stored in an array of character
type, one ASCII character per location. Never forget that, since
strings are conventionally terminated by the null character ``\0'', we
require <I>one extra storage location</I> in the array!
 
</P><P> C does not provide any operator which manipulate entire strings at
once. Strings are manipulated either via pointers or via special
routines available from the standard <I>string</I> library
<KBD>string.h</KBD>. Using character pointers is relatively easy since
the name of an array is a just a pointer to its first element.
Consider the following code:

</P><PRE><HR>
void main()
{
     char text_1[100], text_2[100], text_3[100];
     char *ta, *tb;
     int i;
                                      /* set message to be an arrray  */
                                      /* of characters; initialize it */
                                      /* to the constant string "..." */
                                      /* let the compiler decide on   */
                                      /* its size by using []         */
     char message[] = "Hello, I am a string; what are you?";
 
     printf("Original message: %s\n", message);

                                       /* copy the message to text_1   */
                                       /* the hard way                 */
     i=0;
     while ( (text_1[i] = message[i]) != '\0' )
                i++;
     printf("Text_1: %s\n", text_1);

                                       /* use explicit pointer arithmetic */
     ta=message;
     tb=text_2;
     while ( ( *tb++ = *ta++ ) != '\0' ) 
                               ;
     printf("Text_2: %s\n", text_2);
 
}
<HR>
</PRE>
 
The standard ``string'' library contains many useful functions to
manipulate strings; a description of this library can be found in an
appendix of the K &amp; R textbook. Some of the most useful functions
are:
 
<PRE>char *strcpy(s,ct)     -&gt; copy  ct into s, including ``\0''; return s
char *strncpy(s,ct,n)  -&gt; copy ncharcater of ct into s, return s
char *strncat(s,ct)    -&gt; concatenate ct to end of s; return s
char *strncat(s,ct,n)  -&gt; concatenate n character of ct to end
                           of s, terminate with ``\0''; return s
int strcmp(cs,ct)      -&gt; compare cs and ct; return 0 if cs=ct,
                             &lt;0 if cs<CT and="">0 if cs&gt;ct 
char *strchr(cs,c)     -&gt; return pointer to first occurence of c
                            in cs or NULL if not encountered
size_t strlen(cs)      -&gt; return length of cs
</CT></PRE>
 
(<KBD>s</KBD> and <KBD>t</KBD> are <KBD>char*</KBD>, <KBD>cs</KBD> and
<KBD>ct</KBD> are <KBD>const char*</KBD>, <KBD>c</KBD> is an
<KBD>char</KBD> converted to type <KBD>int</KBD>, and <KBD>n</KBD> is
an <KBD>int</KBD>.)

<P> Consider the following code which uses some of these functions:
 
</P><PRE><HR>
#include &lt; string.h&gt;
 
void main()
{
     char line[100], *sub_text;
					/* initialize string */ 
     strcpy(line,"hello, I am a string;");
     printf("Line: %s\n", line);
					/* add to end of string */ 
     strcat(line," what are you?");
     printf("Line: %s\n", line);
					/* find length of string */ 
 					/* strlen brings back    */
					/* length as type size_t */

     printf("Length of line: %d\n", (int)strlen(line));

					/* find occurence of substrings */ 
     if ( (sub_text = strchr ( line, 'W' ) )!= NULL )
            printf("String starting with \"W\" -&gt;%s\n", sub_text);
 
     if ( ( sub_text = strchr ( line, 'w' ) )!= NULL )
            printf("String starting with \"w\" -&gt;%s\n", sub_text);
 
     if ( ( sub_text = strchr ( sub_text, 'u' ) )!= NULL )
            printf("String starting with \"w\" -&gt;%s\n", sub_text);
 
}
<HR>
</PRE>
 

<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="io">9. I/O Capabilities </A></H2>

<H3> Character level I/O </H3>

C provides (through its libraries) a variety of I/O routines. At the
character level, <KBD>getchar()</KBD> reads one character at a time
from <KBD>stdin</KBD>, while <KBD>putchar()</KBD> writes one character
at a time to <KBD>stdout</KBD>. For example, consider

<PRE><HR>
#include &lt; stdio.h&gt;

void main()
{
    int i, nc;
	
    nc = 0;
    i = getchar();
    while (i != EOF) {
	nc = nc + 1;
	i = getchar();
    }
    printf("Number of characters in file = %d\n", nc);
}
<HR>
</PRE>

This program counts the number of characters in the input stream
(e.g. in a file piped into it at execution time). The code reads
characters (whatever they may be) from <KBD>stdin</KBD> (the
keyboard), uses <KBD>stdout</KBD> (the X-terminal you run from) for
output, and writes error messages to <KBD>stderr</KBD> (usually also
your X-terminal). These streams are always defined at run time. EOF is
a special return value, defined in <KBD>stdio.h</KBD>, returned by
<KBD>getchar()</KBD> when it encounters an <EM>end-of-file</EM> marker
when reading. Its value is computer dependent, but the C compiler
hides this fact from the user by defining the variable EOF.  Thus the
program reads characters from <KBD>stdin</KBD> and keeps adding to the
counter <KBD>nc</KBD>, until it encounters the ``end of file''.

<P>
An experienced C programmer would probably code this example as:

</P><PRE><HR>
#include &lt; stdio.h&gt;

void main()
{
    int c, nc = 0;

    while ( (c = getchar()) != EOF ) nc++;

    printf("Number of characters in file = %d\n", nc);
}
<HR>
</PRE>
C allows great brevity of expression, usually at the expense of
readability!

<P> The <KBD>()</KBD> in the statement <KBD>(c = getchar())</KBD> says
to execute the call to <KBD>getchar()</KBD> and assign the result to
<KBD>c</KBD> before comparing it to EOF; the brackets are necessary
here. Recall that <KBD>nc++</KBD> (and, in fact, also <KBD>++nc</KBD>)
is another way of writing <KBD>nc = nc + 1</KBD>. (The difference
between the prefix and postfix notation is that in <KBD>++nc</KBD>,
<KBD>nc</KBD> is incremented before it is used, while in
<KBD>nc++</KBD>, <KBD>nc</KBD> is used before it is incremented. In
this particular example, either would do.)  This notation is more
compact (not always an advantage, mind you), and it is often more
efficiently coded by the compiler.</P><P>

The UNIX command <KBD>wc</KBD> counts the characters, words and lines
in a file. The program above can be considered as your own
<KBD>wc</KBD>. Let's add a counter for the lines.

</P><PRE><HR>
#include &lt; stdio.h&gt;

void main()
{
    int c, nc = 0, nl = 0;

    while ( (c = getchar()) != EOF )
    {
	nc++;
	if (c == '\n') nl++;
    }

    printf("Number of characters = %d, number of lines = %d\n",
	   nc, nl);
}
<HR>
</PRE>

Can you think of a way to count the number of words in the file?


<H3> Higher-Level I/O capabilities </H3>

We have already seen that <KBD>printf</KBD> handles formatted output
to <KBD>stdout</KBD>. The counterpart statement for reading from
<KBD>stdin</KBD> is <KBD>scanf</KBD>. The syntax

<PRE>	scanf("format string", variables); 
</PRE>

resembles that of <KBD>printf</KBD>. The format string may contain
blanks or tabs (ignored), ordinary ASCII characters, which must match
those in <KBD>stdin</KBD>, and conversion specifications as in
<KBD>printf</KBD>.

<P> Equivalent statements exist to read from or write to character
strings. They are:

</P><PRE>    sprintf(string, "format string", variables);
    scanf(string, "format string", variables);
</PRE>

The ``string'' argument is the name of (i.e. a pointer to) the
character array into which you want to write the information.


<H3> I/O to and from files </H3>

Similar statements also exist for handling I/O to and from files. The
statements are

<PRE>
#include &lt; stdio.h&gt;

    FILE *fp;
										
    fp = fopen(name, mode);
	
    fscanf(fp, "format string", variable list);
    fprintf(fp, "format string", variable list);

    fclose(fp );
</PRE>

The logic here is that the code must 

<UL>
	<LI> define a local ``pointer'' of type <KBD>FILE</KBD> (note that
		the uppercase is necessary here), which is defined in
		&lt; stdio.h&gt;<STDIO.H>
	</STDIO.H></LI><LI> ``open'' the file and associate it with the local pointer via
		<KBD>fopen</KBD>
	</LI><LI> perform the I/O operations using <KBD>fscanf</KBD> and 
		<KBD>fprintf</KBD>
	</LI><LI> disconnect the file from the task with <KBD>fclose</KBD>
</LI></UL>

The ``mode'' argument in the <KBD>fopen</KBD> specifies the
purpose/positioning in opening the file: ``<KBD>r</KBD>'' for reading,
``<KBD>w</KBD>'' for writing, and ``<KBD>a</KBD>'' for appending to
the file. Try the following:

<PRE><HR>
#include &lt; stdio.h&gt;

void main()
{
    FILE *fp;
    int i;

    fp = fopen("foo.dat", "w");        /* open foo.dat for writing */

    fprintf(fp, "\nSample Code\n\n");  /* write some info */
    for (i = 1; i &lt;= 10 ; i++)
	fprintf(fp, "i = %d\n", i);

    fclose(fp);			       /* close the file  */
}
<HR>
</PRE>

Compile and run this code; then use any editor to read the file
<KBD>foo.dat</KBD>.


<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="functions">10. Functions </A></H2>

Functions are easy to use; they allow complicated programs to be
parcelled up into small blocks, each of which is easier to write,
read, and maintain.  We have already encountered the function
<KBD>main</KBD> and made use of I/O and mathematical routines from the
standard libraries.  Now let's look at some other library functions,
and how to write and use our own.


<H3> Calling a Function </H3>

The call to a function in C simply entails referencing its name with
the appropriate arguments. The C compiler checks for compatibility
between the arguments in the calling sequence and the definition of
the function.

<P> Library functions are generally not available to us in source
form.  Argument type checking is accomplished through the use of
header files (like <KBD>stdio.h</KBD>) which contain all the necessary
information.  For example, as we saw earlier, in order to use the
standard mathematical library you must include <KBD>math.h</KBD> via
the statement

</P><PRE>#include &lt; math.h&gt;
</PRE>

at the top of the file containing your code. The most commonly used
header files are

<PRE>&lt; stdio.h&gt;  -&gt; defining I/O routines
&lt; ctype.h&gt;  -&gt; defining character manipulation routines
&lt; string.h&gt; -&gt; defining string manipulation routines
&lt; math.h&gt;   -&gt; defining mathematical routines
&lt; stdlib.h&gt; -&gt; defining number conversion, storage allocation 
              	and similar tasks
&lt; stdarg.h&gt; -&gt; defining libraries to handle routines with variable 
              	numbers of arguments
&lt; time.h&gt;   -&gt; defining time-manipulation routines
</PRE>

In addition, the following header files exist:

<PRE>&lt; assert.h&gt; -&gt; defining diagnostic routines
&lt; setjmp.h&gt; -&gt; defining non-local function calls
&lt; signal.h&gt; -&gt; defining signal handlers
&lt; limits.h&gt; -&gt; defining constants of the int type
&lt; float.h&gt;  -&gt; defining constants of the float type
</PRE>

Appendix B in the K &amp; R book describes these libraries in great
detail.

<H3> <A name="userfunctions"> Writing Your Own Functions </A></H3><A name="userfunctions">

A function has the following layout:

<PRE>return-type function-name ( argument-list-if-necessary )
{
    ...local-declarations...

    ...statements...

    return return-value;
}
</PRE>

If <KBD>return-type</KBD> is omitted, C defaults to
<KBD>int</KBD>. The <KBD>return-value</KBD> must be of the declared
type.

<P> A function may simply perform a task without returning any value,
in which case it has the following layout:

</P><PRE>void function-name ( argument-list-if-necessary )
{
    ...local-declarations...

    ...statements...
}
</PRE>

<P>
As an example of function calls, consider the following code:

</P><PRE><HR>
			/* include headers of library */
			/* defined for all routines   */
			/* in the file                */
#include &lt; stdio.h&gt;
#include &lt; string.h&gt;
			/* prototyping of functions   */
			/* to allow type checks by    */
			/* the compiler               */

void main()
{
    int  n;
    char string[50];
			/* strcpy(a,b) copies string b into a */
			/* defined via the stdio.h header     */
    strcpy(string, "Hello World");

			/* call own function */
    n = n_char(string);	
    printf("Length of string = %d\n", n);	
}

			/* definition of local function n_char */
int n_char(char string[])
{
			/* local variable in this function   */
    int n;
			/* strlen(a) returns the length of   */
			/* string a                          */
			/* defined via the string.h header   */
    n = strlen(string);
    if (n &gt; 50) 
	printf("String is longer than 50 characters\n");

			/* return the value of integer n  */
    return n;
}
<HR>
</PRE>


<P> Arguments are always passed <EM>by value</EM> in C function
calls. This means that local ``copies'' of the values of the arguments
are passed to the routines.  Any change made to the arguments
internally in the function are made only to the local copies of the
arguments. In order to change (or define) an argument in the argument
list, this argument must be passed as an address, thereby forcing C to
change the ``real'' argument in the calling routine.

</P><P> As an example, consider exchanging two numbers between
variables. First let's illustrate what happen if the variables are
passed by value:

</P><PRE><HR>

#include &lt; stdio.h&gt;

void exchange(int a, int b);

void main()
{			/* WRONG CODE */
    int a, b;

    a = 5;
    b = 7;
    printf("From main: a = %d, b = %d\n", a, b);

    exchange(a, b);
    printf("Back in main: ");
    printf("a = %d, b = %d\n", a, b);
}

void exchange(int a, int b)
{
    int temp;

    temp = a;
    a = b;
    b = temp;
    printf(" From function exchange: ");
    printf("a = %d, b = %d\n", a, b);
}
<HR>
</PRE>

Run this code and observe that <KBD>a</KBD> and <KBD>b</KBD> are NOT
exchanged! Only the copies of the arguments are exchanged. The RIGHT
way to do this is of course to use pointers:

<PRE><HR>

#include &lt; stdio.h&gt;

void exchange ( int *a, int *b );

void main()
{			/* RIGHT CODE */
    int a, b;

    a = 5;
    b = 7;
    printf("From main: a = %d, b = %d\n", a, b);

    exchange(&amp;a, &amp;b);
    printf("Back in main: ");
    printf("a = %d, b = %d\n", a, b);
}

void exchange ( int *a, int *b )
{
    int temp;

    temp = *a;
    *a = *b;
    *b = temp;
    printf(" From function exchange: ");
    printf("a = %d, b = %d\n", *a, *b);
}
<HR>
</PRE>
The rule of thumb here is that 
<UL>
	<LI> You use regular variables if the function does
	     not change the values of those arguments<P>
	</P></LI><LI> You MUST use pointers if the function
	     changes the values of those arguments
</LI></UL>

<P><BR></P><HR size="10" width="75%"><P><BR>

</P></A><H2><A name="userfunctions"> </A><A name="command-line">11. Command-line arguments</A></H2>

It is standard practice in UNIX for information to be passed from the
command line directly into a program through the use of one or more
command-line arguments, or <EM>switches</EM>.  Switches are typically
used to modify the behavior of a program, or to set the values of some
internal parameters. You have already encountered several of
these--for example, the <KBD>"ls"</KBD> command lists the files in
your current directory, but when the switch <KBD>-l</KBD> is added,
<KBD>"ls -l"</KBD> produces a so-called ``long'' listing instead.
Similarly, <KBD>"ls -l -a"</KBD> produces a long listing, including
``hidden'' files, the command <KBD>"tail -20"</KBD> prints out the
last 20 lines of a file (instead of the default 10), and so on.<P>

Conceptually, switches behave very much like arguments to functions
within C, and they are passed to a C program from the operating system
in precisely the same way as arguments are passed between functions.
Up to now, the <KBD>main()</KBD> statements in our programs have had
nothing between the parentheses.  However, UNIX actually makes
available to the program (whether the programmer chooses to use the
information or not) two arguments to <KBD>main</KBD>: an <EM>array of
character strings</EM>, conventionally called <KBD>argv</KBD>, and an
<EM>integer</EM>, usually called <KBD>argc</KBD>, which specifies the
number of strings in that array.  The full statement of the first line
of the program is

</P><PRE>    main(int argc, char** argv)
</PRE>

(The syntax <KBD>char** argv</KBD> declares argv to be a pointer to a
pointer to a character, that is, a pointer to a character array (a
character string)--in other words, an array of character strings. You
could also write this as <KBD>char* argv[]</KBD>. Don't worry too much
about the details of the syntax, however--the use of the array will be
made clearer below.)<P>

When you run a program, the array <KBD>argv</KBD> contains, in order,
<EM>all</EM> the information on the command line when you entered the
command (strings are delineated by whitespace), <EM>including the
command itself</EM>.  The integer <KBD>argc</KBD> gives the total
number of strings, and is therefore equal to equal to the number of
arguments <EM>plus one</EM>. For example, if you typed

</P><PRE>	a.out -i 2 -g -x 3 4
</PRE>

the program would receive

<PRE>	argc = 7
	argv[0] = "a.out"
	argv[1] = "-i"
	argv[2] = "2"
	argv[3] = "-g"
	argv[4] = "-x"
	argv[5] = "3"
	argv[6] = "4"
</PRE>

Note that the arguments, even the numeric ones, are all
<EM>strings</EM> at this point.  It is the programmer's job to decode
them and decide what to do with them.<P>

The following program simply prints out its own name and arguments:

</P><PRE>#include &lt; stdio.h&gt;

main(int argc, char** argv)
{
    int i;

    printf("argc = %d\n", argc);

    for (i = 0; i &lt; argc; i++)
	printf("argv[%d] = \"%s\"\n", i, argv[i]);
}
</PRE>

UNIX programmers have certain conventions about how to interpret the
argument list.  They are by no means mandatory, but it will make your
program easier for others to use and understand if you stick to them.
First, switches and key terms are always preceded by a ``-''
character.  This makes them easy to recognize as you loop through the
argument list.  Then, depending on the switch, the next arguments may
contain information to be interpreted as integers, floats, or just
kept as character strings.  With these conventions, the most common
way to ``parse'' the argument list is with a <KBD>for</KBD> loop and a
<KBD>switch</KBD> statement, as follows:

<PRE>#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;

main(int argc, char** argv)
{
    /* Set defaults for all parameters: */

    int a_value = 0;
    float b_value = 0.0;
    char* c_value = NULL;
    int d1_value = 0, d2_value = 0;

    int i;

    /* Start at i = 1 to skip the command name. */

    for (i = 1; i &lt; argc; i++) {

	/* Check for a switch (leading "-"). */

	if (argv[i][0] == '-') {

	    /* Use the next character to decide what to do. */

	    switch (argv[i][1]) {

		case 'a':	a_value = atoi(argv[++i]);
				break;

		case 'b':	b_value = atof(argv[++i]);
				break;

		case 'c':	c_value = argv[++i];
				break;

		case 'd':	d1_value = atoi(argv[++i]);
		                d2_value = atoi(argv[++i]);
				break;

	    }
	}
    }

    printf("a = %d\n", a_value);
    printf("b = %f\n", b_value);
    if (c_value != NULL) printf("c = \"%s\"\n", c_value);
    printf("d1 = %d, d2 = %d\n", d1_value, d2_value);
}
</PRE>

Note that <KBD>argv[i][j]</KBD> means the <KBD>j</KBD>-th character of
the <KBD>i</KBD>-th character string. The <KBD>if</KBD> statement
checks for a leading ``-'' (character 0), then the <KBD>switch</KBD>
statement allows various courses of action to be taken depending on
the next character in the string (character 1 here).  Note the use of
<KBD>argv[++i]</KBD> to increase <KBD>i</KBD> before use, allowing us
to access the next string in a single compact statement.  The
functions <KBD>atoi</KBD> and <KBD>atof</KBD> are defined in
<KBD>stdlib.h</KBD>.  They convert from character strings to
<KBD>ints</KBD> and <KBD>doubles</KBD>, respectively.<P>

A typical command line might be:

</P><PRE>	a.out -a 3 -b 5.6 -c "I am a string" -d 222 111
</PRE>

(The use of double quotes with <KBD>-c</KBD> here makes sure that the
shell treats the entire string, including the spaces, as a single
object.)<P>

Arbitrarily complex command lines can be handled in this way.
Finally, here's a simple program showing how to place parsing
statements in a separate function whose purpose is to interpret the
command line and set the values of its arguments:

</P><PRE>

			/********************************/
			/*                        	*/
			/*   Getting arguments from    	*/
			/*				*/
			/*      the Command Line        */
			/*				*/
			/********************************/


					/* Steve McMillan 	*/
					/* Written: Winter 1995	*/


#include &lt; stdio.h&gt;
#include &lt; stdlib.h&gt;

void get_args(int argc, char** argv, int* a_value, float* b_value)
{
    int i;

    /* Start at i = 1 to skip the command name. */

    for (i = 1; i &lt; argc; i++) {

	/* Check for a switch (leading "-"). */

	if (argv[i][0] == '-') {

	    /* Use the next character to decide what to do. */

	    switch (argv[i][1]) {

		case 'a':	*a_value = atoi(argv[++i]);
				break;

		case 'b':	*b_value = atof(argv[++i]);
				break;

		default:	fprintf(stderr,
				"Unknown switch %s\n", argv[i]);
	    }
	}
    }
}

main(int argc, char** argv)
{
    /* Set defaults for all parameters: */

    int a = 0;
    float b = 0.0;

    get_args(argc, argv, &amp;a, &amp;b);

    printf("a = %d\n", a);
    printf("b = %f\n", b);
}

</PRE>

<P><BR></P><HR size="10" width="75%"><P><BR>

</P><H2> <A name="dialog-box">12. Graphical Interfaces: Dialog Boxes</A></H2>

Suppose you don't want to deal with command line interpretation, but
you still want your program to be able to change the values of certain
variables in an interactive way.  You could simply program in a series
<KBD>printf/scanf</KBD> lines to quiz the user about their
preferences:

<P>
</P><PRE>	.
	.
	.
	printf("Please enter the value of n: ");
	scanf("%d", &amp;n);

	printf("Please enter the value of x: ");
	scanf("%f", &amp;x);

	.
	.
	.

</PRE>
<P>

and so on, but this won't work well if your program is to be used as
part of a pipeline (see the <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/UNIX/unix.html">UNIX</A>
primer), for example using ther graphics program <A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/Graphics/basic_graphics.html#plot_data"><KBD>plot_data</KBD></A>,
since the questions and answers will get mixed up with the data
stream.

</P><P> A convenient alternative is to use a simple graphical interface
which generates a <EM>dialog box</EM>, offering you the option of
varying key parameters in your program.  Our graphics package provides
a number of easy-to-use tools for constructing and using such boxes.
The simplest way to set the integer variable <KBD>n</KBD> and the
float variable <KBD>x</KBD> (i.e. to perform the same effect as the
above lines of code) using a dialog box is as follows:

</P><PRE>/* Simple program to illustrate use of a dialog box */
	
main()
{
    /* Define default values: */

    int n = 0;
    float x = 0.0;

    /* Define contents of dialog window */

    create_int_dialog_entry("n", &amp;n);
    create_float_dialog_entry("x", &amp;x);

    /* Create window with name "Setup" and top-left corner at (0,0) */

    set_up_dialog("Setup", 0, 0);

    /* Display the window and read the results */

    read_dialog_window();

    /* Print out the new values */

    printf("n = %d, x = %f\n", n, x);
}
</PRE>

Compile this program using the alias <KBD>Cgfx</KBD> (see the page on
<A href="http://www.physics.drexel.edu/students/courses/Comp_Phys/General/C_basics/compile.html">compilation</A>) to link in all necessary
libraries.

<P>The two <KBD>create</KBD> lines define the entries in the box and
the variables to be associated with them, <KBD>set_up_dialog</KBD>
names the box and defines its location.  Finally,
<KBD>read_dialog_window</KBD> pops up a window and allows you to
change the values of the variables.  When the program runs, you will
see a box that looks something like this:

</P><P>
</P><CENTER><IMG src="./C Tutorial_files/dialog.gif"></CENTER>
<P>

Modify the numbers shown, click "OK" (or just hit carriage return),
and the changes are made.  That's all there is to it!  The great
advantage of this approach is that it operates <EM>independently</EM>
of the flow of data through <KBD>stdin/stdout</KBD>.  In principle,
you could even control the operation of every stage in a pipeline of
many chained commands, using a separate dialog box for each.


</P></BODY></HTML>