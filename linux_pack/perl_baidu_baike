perl

基本信息

　　Perl 最初的设计者为拉里·沃尔（Larry Wall），他于1987年12月18日发表。Perl借取了C、sed、awk、shell scripting以及很多其他程序语言的特性。
　　Perl 一般被称为“实用报表提取语言”（PracticalExtraction andReportLanguage），虽然有时被称做“病态折中垃圾列表器”(PathologicallyEclectic Rubbish Lister)。它是术语，而不仅仅是简写，Perl的创造者，Larry Wall提出第一个，但很快又扩展到第二个。那就是为什么“Perl”没有所有字母都大写。没必要争论哪一个正确，Larry 两个都认可。
　　你也可能看到“perl”，所有的字母都是小写的。一般，“Perl”，有大写的 P，是指语言本身，而“perl”，小写的 p，是指程序运行的解释器。
　　Perl的正式网站是 http://www.perl.org。
[编辑本段]Perl是什么?

　　Perl是由Larry Wall设计的，并由他不断更新和维护的编程语言。
　　.Perl具有高级语言（如C）的强大能力和灵活性。事实上，你将看到，它的许多特性是从C语言中借用来的。
　　.与脚本语言一样，Perl不需要编译器和链接器来运行代码，你要做的只是写出程序并告诉Perl来运行而已。这意味着Perl对于小的编程问题的快速解决方案和为大型事件创建原型来测试潜在的解决方案是十分理想的。
　　.Perl提供脚本语言（如sed和awk）的所有功能，还具有它们所不具备的很多功能。Perl还支持sed到Perl及awk到Perl的翻译器。
　　简而言之，Perl象C一样强大，象awk、sed等脚本描述语言一样方便。
[编辑本段]Perl 的特点

　　Perl的解释程序是开放源码的免费软件，使用Perl不必担心费用。Perl能在绝大多数操作系统运行，可以方便地向不同操作系统迁移。
　　Perl 是一种能完成任务的语言。从一开始，Perl 就设计成可以把简单工作简单化，同时又不失去处理困难问题能力的语言。它可以很容易操作数字，文本，文件和目录，计算机和网络，特别是程序的语言。这种语言应该很容易运行外部的程序并且扫描这些程序的输出获取感兴趣的东西。而且它还应该很容易能把这些你感兴趣的东西交给其它程序做特殊的处理。当然，这种语言还应该很容易在任何现代的操作系统上可以移植地编译和运行。
[编辑本段]Perl 基本语法

　　变量定义，以$号开头，如：$num =1;
　　数组定义，以@开头，如：@array = (1,2,3);
　　数组元素调用 $array[index]，其中index表示数组下标，如上例，$array[0]的值是1
　　散列定义，以%开头，如：%hash=("a",1,"b",2);
　　散列调用 %hash，其中keys表示键值，多用字符串表示，如上例中的"a", "b", vaules是keys对应的值，如1，2。$hash{"b"}的值是2。
[编辑本段]Perl 的哲学

　　Perl追求的是简单, 解决一个一般的问题用它几行代码就完成了. 一个稍复杂一点的问题代码也不会超过一屏! 事实上, 大多数人用Perl写的程序大多都没超过100行.
　　Perl 最初是当做一种 Unix 的胶水语言设计的，但是她早就移植到大多数其它操作系统里了。因为 Perl 几乎可以在任何地方运行，所以 Perl 可以说是当今最具有移植性的编程环境。要想写可移植的 C/C++ 程序，你得在程序里加上一大堆 #ifdef 标签来区分不同的系统。要想写可移植的 Java 程序，你必须理解每种新的 Java 实现的特质。要想写可移植的shell，你可能要记住每条命令在每种操作系统上的语法，走运的时候你可能可以找到一些公共的东西。而要想写可移植的 Visual Basic 程序，那么你只需要对“移植”有个更灵活的定义就可以了。
　　我们很高兴的是 Perl 避免了所有这些问题，同时还保留了这些语言中的许多优点，同时还有一些自己的特色。Perl 的特色来自许多方面：它的特性集的工具，Perl 社区的创造性，以及开源运动的大环境。不过，许多这些特性都是混合的东西；Perl 的身世复杂，它总是把事物看成是优点的不同方面，而不是弱点。Perl 是“背黑锅我来”的语言。如果你觉得自己陷入一团乱麻之中，非常渴望自由，那么请使用 Perl。
　　Perl 是跨文化的。Perl 的爆炸性增长很大程度上是因为那些前 Unix 系统程序员的渴望，他们希望从他们的“老家”带着尽可能多的东西。对于他们而言，Perl 是可移植的 Unix 文化蒸馏器，是"此路不通"的沙漠中的绿洲。从另外一个角度来看，Perl 还可以从另外一个方向运转：在 Windows 上工作的 web 设计者通常会非常开心地发现他们的 Perl 程序可以不加修改地在 Unix 服务器上跑。
　　尽管 Perl 在系统程序员和 web 设计师中间非常流行，但这只是因为是他们最早发现 Perl 的，Perl 可以用于更广泛的用途。从 Perl 最早的文本处理语言开始，它已经发展成为一种非常复杂的，通用的编程语言，以及完整的开发环境，包括调试器，调节器，交叉引用，编译器，库，语法提示编辑器，以及所有其它“真正”的编程语言所具有的所有挂勾，只要你需要。当然这些东西都是让我们可能处理难的问题的东西，而且很多其它语言也可以做到这一点。Perl 之所以成为 Perl 是因为它从来不会因为保持简单事情简单化而丢失其他方面的特性。
　　因为 Perl 既强大又好用，所以它被广泛地用于日常生活的方方面面，从宇航工程到分子生物学，从数学到语言学，从图形处理到文档处理，从数据库操作到网络管理。很多人用 Perl 进行快速处理那些很难分析或转换的大批量数据，不管你是处理 DNA 序列，网页，还是猪肚皮的未来都无所谓。实际上，在 Perl 社区有一个笑话就是，下次股市大崩盘就很有可能是哪个家伙写的脚本里头有臭虫造成的。（不过，乐观点来看就是，任何还在失业的股票分析师仍然有可以利用的技巧。）
　　Perl 的成功有许多原因。Perl 早在开源软件的名字出现之前就已经是一个成功的开源项目了。Perl 是自由的，并将永远自由下去。你可以在任何合适的场合使用 Perl，只需要遵守一个非常自由的版权就可以了。如果你在从事商业活动并且还想使用 Perl，那么用就是了。你可以把 Perl 嵌入到你写的商业软件中而不需要支付任何费用也没有任何限制。如果你碰上一个 Perl 社区解决不了的问题，那你也还有最后的一招：源程序本身。 Perl 社区不会在“升级”的伪装下租给你它们的商业秘密。而且 Perl 社区也不会“停业 ”，更不会让你孤立无援。
　　Perl 是自由软件这一点无疑对它是有帮助的。但这一条并不足以解释 Perl 现象，因为许多自由软件包没有能繁荣起来。Perl 不仅自由；而且好玩。人们觉得自己在 Perl 里可以有创造力，因为它们有表达的自由：他们可以选择是为计算机速度优化还是为程序员的速度优化，是冗长还是简洁，是选择可读性还是可维护性，或者选择复用性，移植性，接受性和传授性等等。假如你进入一次模糊的 Perl 比赛，甚至你还可以为模糊性做优化。
　　Perl 可以给予你所有这些自由，因为它是一门有着分裂人格的语言。Perl 同时是很简单并且很富有的语言。Perl 从其它地方拿来好主意，然后把它们安装到易用的框架里面。对于只是喜欢她的人来说，Perl 是实用抽取和报表语言（Practical Extractoin and Report Language）。对那些热爱她的人而言，她是变态电子垃圾制造者（Pathologically Electric Rubbish Lister）。在少数人眼里，Perl 是毫无意义的重复练习。不过世界需要一点点冗余。精简主义者总是想把事物分隔开。而我们则总是企图把它们合并到一起。
　　Perl 之所以是简单的语言是有很多原因的。比如你用不着知道什么特殊的指令就可以编译 Perl 程序--只要把它当做批处理或者 shell 脚本执行就可以了。Perl 的类型和结构很容易使用和理解。Perl 对你的数据没有任何限制--你的字串和数组可以要多长就多长（只要你有足够的内存），而且它们都会自动增长。Perl 不会强迫你学习新的语法和语意，Perl 改从许多其它你已经熟悉的语言里（比如 C, awk, BASIC 和 Python, 英文，希腊语等）借来语法。实际上，任何程序员都可以从书写良好的 Perl 代码段中读懂它的含义。
　　最重要的是，你不用先学习所有 Perl 的东西就可以开始写有用的程序。你可以写很小的 Perl 程序。你也可以象小孩那样写 Perl 程序，我们保证不会笑话你。或者更准确地说是，我们绝不会笑话小孩做事情的创造性。Perl 里的许多观点都是从自然语言中借来的，其中一条最好的观点就是只要你能把自己的意思表述清楚，那么你就可以使用这些语言的一个子集。Perl 文化可以接受任何熟练程度的成员。我们不会在你背后放个语言警察。如果你的老板不炒你，而且你的 Perl 脚本也能完成工作，那么它就是“正确”的。
　　尽管 Perl 很简单，但它仍然是一种特性很丰富的语言，如果你想用那些特性的话，那你就要学习一些东西。这也是把难题变简单的学费。虽然你要想把所有 Perl 能做的事情吸收还需要一些时间，但到你需要这些功能的时候你就会非常开心地发现 Perl 已经可以做这些事情了。
　　由于 Perl 的继承性，就算它只是用做数据归纳语言的时候也有丰富的特性，Perl 一开始就设计成可以浏览文件，扫描大量文本并且生成动态数据以及打印出这些数据的良好格式化的报表。不过，随后 Perl 就开始风行，于是它就成了可以操作文件系统，进程管理，数据库管理，进行 C/S 编程和安全编程，web 信息管理，甚至可以进行面向对象和面向功能的编程的语言。而且这些功能并非只是在 Perl 这边，每种新功能都和其它东西交流得很好，别忘了 Perl 从一开始就是设计成胶水语言的。
　　而且 Perl 并不仅仅只能黏合它自己的特性。Perl 是设计成可以用模块扩展的语言。你可以用 Perl 快速设计，编写，调试和部署 Perl 应用，并且你还可以在需要的时候很方便地扩展这些应用。你可以在其它语言里嵌入 Perl，而且你也可以在 Perl 里嵌入其它语言。通过模块输入机制，你可以把这些外部的扩展当做内置于 Perl 的特性。那些面向对象的外部库在 Perl 内部仍然保持面向对象的特征。
　　Perl 还在许多其它方面协助你。和严格的每次执行一条命令的命令文件和 shell 脚本不同的是，Perl 先把你的程序快速编译成一种内部格式。和其它任何编译器一样，这个时候还进行各种优化，同时把碰到的任何问题反馈给你。一旦 Perl 的编译器前端对你的程序表示满意了，它就把这些中间代码交给解释器执行（或者是给其它的能生成 C 或者字节码的模块后端）。听起来挺复杂，不过 Perl 的编译器和解释器干这些活效率相当高，我们的编译-运行-修改的过程几乎都是以秒计。再加上 Perl 的许多其他开发特性，这种快速的角色转换很适合做快速原型设计。然后随着你的程序的成熟，你可以逐步拧紧身上的螺母，减少散漫增强记律。如果你做得好，Perl 也能帮你这个忙。
　　Perl 还可以帮你写更安全的程序。除了其它语言提供的典型的安全接口之外，Perl 还通过一种跟踪数据的机制给你提供预防意外安全错误的保护，这样就可以在灾害发生之前预防其发生。最后，Perl 还可以让你设置一个特殊的防护隔段运行那些来源不明的 Perl 代码，以此来杜绝危险操作。
　　不过，偏执一点儿说，Perl 帮你的大部分内容和 Perl 本身没有什么关系，而是和使用 Perl 的人有关。坦率地说，Perl 社区的人们可以说是地球上最热心的人了。如果 Perl 运动里面有那么一点点宗教色彩的话，那么这就是它的核心了。Larry 希望 Perl 社区像一小片天堂那样运转，目前看来他的愿望基本上是实现了。我们也请你为此做出自己的努力。
　　Perl之所以强大, 是因为有CPAN, CPAN上面有无数的开源模块, 从科学计算到桌面应用到网络等等各个方面都有大量的模块! 并且现在世界上也还有无数的人在向上面添加模块! 如果你想要用PERL实现某功能, 不用自己做, 在CPAN上面搜一搜, 多半都会得到已有的结果! CPAN（"the Comprehensive Perl Archive Network"全面的 Perl 存档网络）是查找任何 Perl 有关的东西的中心仓库。它包含从整个 Perl 社区收集来的智慧：成百上千的 Perl 模块和脚本，相当于好几本书的文档，以及整个 Perl 发布。如果有东西是用 Perl 写的，而且这个东西很有用而且是自由的，那么它很有可能就在 CPAN 上。CPAN 在全世界都有镜象，你可以在位于 http://www.perl.com/CPAN 的 CPAN 路牌上找到离你最近的镜象。那块路牌会记住你选择的是哪个镜象并且你以后再访问 http://www.perl.com/CPAN/（注意最后的斜杠）的时候就会自动重新定向到那个镜象。另外，你也可以从 www.cpan.org开始。这个站的界面不同，但是数据是一样的。
[编辑本段]Perl 文化

　　1.时势造英雄
　　为了理解 Perl 为什么用现在这样的样子定义（或者为什么不定义成其他的样子），我们必须首先明白为什么会有 Perl。所以，让我们先挖掘一下步满尘灰的历史书....
　　退回到 1986 年，Larry 是一个系统程序员，在做一个多层安全的广域网项目的开发。他负责这么一个系统，这个系统由西海岸的三台 VAX 和三台 sun 机器，通过一条加密了的 1200 波特的串行线路和东海岸类似配置的系统连接组成的，因为 Larry 的主要工作是支持（他不是该项目的程序员，只是系统专家），所以他就有机会利用他的三种优点（懒惰，不耐心，和狂傲）来开发和提高所有有用的工具——比如 rn，patch，和 warp。（注：正是在这个时候，Larry 被划入了“计算机动物”的范畴，这是以那些人的不可遏止的“再加一个特性”的渴望为基础评判的，因为这种行为几乎成了生物必须。毕竟，如果生活就是太复杂的话，难道程序就不会吗？尤其是想 rn 这样的程序，它真是应该当作一个高级的人工智能项目来看待，因为他们就可以为你阅读新闻。当然，有些人已经在说 patch 程序太复杂了。）
　　一天，Larry 刚刚把 rn 撕成碎片，把它一片一片地放在他的目录里，大管理员就跑进来说， “Larry，我们需要一个管理配置，用它控制所有六台 VAX 和六台 sun。我们想在一个月里就要它。你做一个吧！”
　　所以，从不逃避工作的 Larry，开始问自己做一个两个海岸的 CM 系统的最好的方法是什么，它必须不用自己从头开始写，并且还可以查阅两个海岸的问题报告以及核准和控制。他想到的答案只有一个词：B-news。（注：也就是 Usenet 传输软件的第二种实现。）
　　Larry 着手在这些机器上安装了新闻软件并且增加了两条控制命令：一条“append”命令用于向现有的文章追加内容，和一条“synchronize”命令保持两个海岸的文章数目相同。CM 可以用 RCS （版本控制系统）做，而核准和控制可以用新闻和 rn 来做。到目前挺好。
　　然后大管理员让他生成报告。新闻是在核心机器里的一个独立的文件里维护的，里面有许多文件间的交叉引用。Larry 的第一个反应是“用 awk。”糟糕的是，那个时候的 awk 无法做到以文件里的信息为基础打开和关闭多个文件。Larry 不想编写一个特殊目的的工具。结果就是产生了一种新的语言。
　　最初这种新的语言并不叫 Perl。Larry 和他的同事及亲友（Dan Faigin，写这段历史的人，和 Mark Biggar，他的妻弟，在初始设计阶段帮了大忙）交换了一大堆名字。实际上 Larry 考虑并抛弃了字典里的所有三个或四个字母的单词。最早的名字是“Gloria”，以他的宝贝（和老婆）命名。但他很快就发现这样会产生太多家庭混乱。
　　然后名字就成了“Pearl”，最后它变成了我们现在的“Perl”，部分原因是 Larry 看到另外一种叫 PEARL 的语言的介绍，但最主要的原因是他懒得总要敲五个键。当然，这样 Perl 就可以用做一个四字母的词。（不过，你会注意到，这里有以前首字缩写的残余： “Practical Extraction And Report Language”。）
　　最早的 Perl 没有今天的 Perl 那么多的特性。那时候有模式匹配和文件句柄，有标量，有格式化，但是很少有函数，没有相关的数组，而且只有一个实现得不怎么样的正则表达式，（从 rn 借来的）。手册页也只有 15 页。但是 Perl 比 sed 和 awk 快，并且开始在该项目的其他应用里使用。
　　但是其他地方又开始需要 Larry 了。有一天另外一个大经理来了并且说：“Larry，给 R&D 做支持。”并且 Larry 说，好吧。他带上 Perl 并且很快发现它逐渐成为系统管理的好工具。他借来 Henry Spencer 漂亮的正则表达式软件包并且把它变成更有男人味（不过 Henry 可能不会愿意在正餐的时候考虑这些特性。）然后 Larry 增加了大部分他想要的特性，以及一些别人想要的特性。然后它就把 Perl 发布到网络上。（注：更让人吃惊的是，他先后工作于喷气推进实验室（JPL），然后是 NetLabs? 和 Seagate 之后，仍然不断发布新 Perl。现在，其他人做了大部分工作，而 Larry 假装为 O'Reilly & Associates（一个小公司，印刷关于计算机和相关事物的小册子。）其余的就是历史了。（注：而这些东西，是历史的一个注解。当开始 Perl 的工作的时候，Larry 已经把 rn 分解成碎片，并且准备做一次全面的重写。但因为他开始在 Perl 上干活，所以 Larry 没有再碰 rn。它仍然是碎片。有时候 Larry 说要用 Perl 重写 rn，但是从来没当真。）
　　然后事情的发展就是这样的：Perl 1.0 在 1987 年十二月十八日发布；有些人仍然很认真地对待 Perl 的生日。Perl 2.0 在 1988 年六月发布，并且 Randal Schwartz 开始了“另外一个 Perl 黑客”的签名的传奇。在 1989 年，Tom Christiansen 在巴尔的摩 Usenix 拿出了第一个公开的 Perl 教程。1989 年十月的 Perl 3.0开始，这门语言第一次以 GNU 公众版权（GPL）发布和分发。
　　1990 年三月，Larry 写了第一首 Perl 小诗（见下一节）。然后他和 Randal 写了本书的第一版，The Pink Camel；该书在 1991 年早期发行。然后 Perl 4.0 就立即发布了；除 GPL 之外，它还包括了 Artistic License（艺术版权）。
　　万众期待的 Perl 5 在 1994 年十月发布。这是一个完全重写的 Perl 版本，它包括对象和模块。 Perl 5 的到来甚至连 The Ecomomist 杂志都提到。到了 1995 年，正式向 Perl 社区引入 CPAN。在 1996 年，Jon Orwant 开始出版 The Perl Journal 杂志。在长时间的猜测之后，本书的第二版，The Blue Camel，在那年的年末出版。第一次 O'Reilly Perl 大会（TPC） 1997 年夏季在加州 San Jose 举行。现在，重大时间几乎是每天都在发生，所以，关于历史的其他部分，请检查 CPAST （Comprehensive Perl Arcana Society Tapestry （history.perl.org））上的 Perl 纪年表。
　　2. Perl 诗歌
　　在助手框里的诗歌的仿制品是在1990年的四月一日愚人节张贴到 Usenet 上的。我们不加注释的把它放在这里，只是想表示典型的编程语言的隐喻真的是多么让人作呕。对所有有文学价值的东西大概都是这样的吧。Larry 在最初为 Perl 3 写的那些“Black Perl”到了 Perl 5 不能分析通过之后，真是感觉轻松许多。
　　不过，Larry 自己的文集很幸运地被 Perl 诗歌的王后，Sharon Hopkins 的光芒所掩盖。她写了相当多的 Perl 诗歌，以及一些她在 1992 年 Usenet 冬季技术大会上拿出来的关于 Perl 诗歌的文章，标题是“Camels and Needles: Computer Poetry Meets the Perl Programming Language”。（这篇文章可以在 CAPN 的 misc/poetry.ps 找到。）除了是最多产的 Perl 诗人之外，Sharon 还是下面这首诗歌的作者，这首诗是发表得最广泛的一首，并且曾经在 Economist 和 Guardian 杂志上刊登：
　　#!/usr/bin/perl
　　APPEAL:
　　listen (please, please);
　　open yourself, wide;
　　join (you, me),
　　connect (us,together),
　　tell me.
　　do something if distressed;
　　@dawn, dance;
　　@evening, sing;
　　read (books,$poems,stories) until peaceful;
　　study if able;
　　write me if-you-please;
　　sort your feelings, reset goals, seek (friends, family, anyone);
　　do*not*die (like this)
　　if sin abounds;
　　keys (hidden), xXyz (locks, doors), tell secrets;
　　do not, I-beg-you, close them, yet.
　　accept (yourself, changes),
　　bind (grief, despair);
　　require truth, goodness if-you-will, each moment;
　　select (always), length(of-days)
　　# listen (a perl poem)
　　# Sharon Hopkins
　　# rev. June 19, 1995
　　Perl Poetry
　　Article 970 of comp.lang.perl:
　　Path: jpl-devvax!pl-dexxav!lwall
　　From: lwall@jpl-dexxav.JPL.NASA.GOV(Larry Wall)
　　Newsgroups: news.groups,rec.arts.poems,comp.lang.perl
　　Subject: CALL FOR DISCUSSION: comp.lang.perl.poems
　　Message-ID: <0401@jpl-devvax.JPL.NASA.GOV>
　　Date: 1 Apr 90 00:00:00 GMT
　　Reply-To: lwall@jpl-devvax.JPL.NSAS.GOV(Larry Wall)
　　Organization: Jet Prepulsion Laboratory, Pasadena, CA
　　Lines: 61
　　It has come to my attention that there is a crying need for a place for people to express both their emotional
　　and technical natures simultaneously. Several people have sent me some items which don't fit into any
　　newsgroup. Perhaps it's because I recently posted to both comp.lang.perl and to rec.arts.poems, but people
　　seem to be writing poems in Perl, and they're asking me where they should post them. Here is a sampling:
　　From a graduate student (in finals week), the following haiku:
　　study, write, study,
　　do review (each word) if time.
　　close book. sleep? what's that?
　　And someone writing from Fort Lauderdale writes:
　　sleep, close together,
　　sort of sin each spring & wait;
　　50% die
　　A person who wishes to remain anonymous wrote the following example of "Black Perl". (The Pearl poet
　　would have been shocked, no doubt.)
　　BEFOREHAND: close door, each window & exit; wait until time.
　　open spellbook, study, read (scan, select, tell us);
　　write it, print the hex while each watches,
　　reverse its length, write again;
　　kill spiders, pop them, chop, split, kill them.
　　unlink arms, shift, wait & listen (listening, wait),
　　sort the flock (then, warn the "goats" & kill the "sheep");
　　kill them, dump qualms, shift moralities,
　　values aside, each one;
　　die sheep! die to reverse the system
　　you accept (reject, respect);
　　next step,
　　kill the next sacrifice, each sacrifice,
　　wait, redo ritual until "all the spirits are pleased";
　　do it ("as they say").
　　do it(*everyone***must***participate***in***forbidden**s*e*x*).
　　return last victim; package body;
　　exit crypt (time, times & "half a time") & close it,
　　select (quickly) & warn your next victim;
　　AFTERWORDS: tell nobody.
　　wait, wait until time;
　　wait until next year, next decade;
　　sleep, sleep, die yourself,
　　die at last
　　I tried that, and it actually parses in Perl. It doesn't appear to do anything useful, however. I think I'm glad,
　　actually... I hereby propose the creation of comp.lang.perl.poems as a place for such items, so we don't clutter
　　the perl or poems newsgroups with things that may be of interest to neither. Or, alternately, we should
　　create rec.arts.poems.perl for items such as those above which merely parse, and don't do anything useful.
　　(There is precedent in rec.arts.poems, after all.) Then also create comp.lang.perl.poems for poems that
　　actually do something, such as this haiku of my own:
　　print STDOUT q
　　Just another Perl hacker,
　　unless $spring
　　Larry Wall lwall@jpl-devvax.jpl.nasa.gov

